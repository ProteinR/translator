// ==UserScript==
// @name         Lokalise Auto-Translator (Gemini 3.12 - Final)
// @namespace    http://tampermonkey.net/
// @version      3.12
// @grant        GM_xmlhttpRequest
// @connect      generativelanguage.googleapis.com
// @match        https://app.lokalise.com/project/*
// ==/UserScript==

// ============================================================
// 1. –í–ê–® –ö–û–ù–§–ò–ì
// ============================================================
function getScriptConfig() {
    return {
        GEMINI_API_KEY: '', // <-- –í–°–¢–ê–í–¨–¢–ï –í–ê–® –ö–õ–Æ–ß –¢–£–¢
        TARGET_LANG_ID: '748',
        SOURCE_LANG_ID: '640',
        MODEL: "gemini-2.5-flash", 

        // --- –ó–ê–î–ï–†–ñ–ö–ò (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö) ---
        SCROLL_DELAY: 2000,              
        EDITOR_LOAD_DELAY: 1500,         
        FOCUS_DELAY: 300,                
        BEFORE_SAVE_DELAY: 800,          
        SAVE_CHECK_DELAY: 200,           
        ROW_NEXT_DELAY: 600              
    };
}
// ============================================================
// –ö–û–ù–ï–¶ –ö–û–ù–§–ò–ì–ê
// ============================================================

(function() {
    'use strict';

    const CONFIG = getScriptConfig();
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    let translationMap = new Map(); 
    let isStopped = false;

    // –§—É–Ω–∫—Ü–∏—è –∑–≤—É–∫–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞
    function playSuccessSound() {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // –ù–æ—Ç–∞ –õ—è
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

        oscillator.start();
        oscillator.stop(audioCtx.currentTime + 0.5);
    }

    // –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    const container = document.createElement('div');
    container.style = 'position:fixed;top:10px;right:10px;z-index:9999;display:flex;gap:5px;';
    document.body.appendChild(container);

    const startBtn = document.createElement('button');
    startBtn.innerHTML = 'üöÄ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–≤–æ–¥–∞';
    startBtn.style = 'padding:10px;background:#1a73e8;color:#fff;border:none;border-radius:5px;cursor:pointer;font-weight:bold;box-shadow: 0 2px 5px rgba(0,0,0,0.2);';

    const stopBtn = document.createElement('button');
    stopBtn.innerHTML = 'üõë Stop';
    stopBtn.style = 'padding:10px;background:#dc3545;color:#fff;border:none;border-radius:5px;cursor:pointer;font-weight:bold;display:none;';

    container.appendChild(startBtn);
    container.appendChild(stopBtn);

    stopBtn.onclick = () => { isStopped = true; console.warn("üõë –ü—Ä–æ—Ü–µ—Å—Å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º."); };

    startBtn.onclick = async () => {
        if (!CONFIG.GEMINI_API_KEY) {
            alert("–û—à–∏–±–∫–∞: –í—Å—Ç–∞–≤—å—Ç–µ API –∫–ª—é—á –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å–∫—Ä–∏–ø—Ç–∞!");
            return;
        }

        console.log(`%c--- –ó–ê–ü–£–°–ö 3.12 [ID MAPPING + SOUND] ---`, "color: #1a73e8; font-weight: bold;");
        isStopped = false;
        startBtn.disabled = true;
        stopBtn.style.display = 'block';
        translationMap.clear();

        try {
            if (!(await scrollAndCollect()) || isStopped) return;

            if (translationMap.size === 0) {
                console.log("%c--- –ü–£–°–¢–´–• –°–¢–†–û–ö –ù–ï –ù–ê–ô–î–ï–ù–û ---", "color: green; font-weight: bold;");
                return;
            }

            if (!(await translateWithGemini()) || isStopped) return;
            await fillTranslations();
            
            console.log("%c--- –í–°–ï –û–ü–ï–†–ê–¶–ò–ò –ó–ê–í–ï–†–®–ï–ù–´ ---", "color: #28a745; font-weight: bold;");
            playSuccessSound(); // –ó–≤—É–∫–æ–≤–æ–π —Å–∏–≥–Ω–∞–ª

        } catch (err) {
            console.error(`‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: ${err}`);
        } finally {
            startBtn.disabled = false;
            startBtn.innerHTML = 'üöÄ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–≤–æ–¥–∞';
            stopBtn.style.display = 'none';
        }
    };

    async function scrollAndCollect() {
        let lastHeight = 0;
        let sameHeightCount = 0;
        while (sameHeightCount < 3) {
            if (isStopped) return false;
            const rows = document.querySelectorAll('.row-key[data-id]');

            for (let row of rows) {
                const id = row.getAttribute('data-id');
                const originalText = row.querySelector(`.base-cell-trans .highlight`)?.innerText;
                const targetCell = row.querySelector(`.cell-trans[data-lang-id="${CONFIG.TARGET_LANG_ID}"] .highlight`);
                const isEmpty = !targetCell || targetCell.querySelector('.empty') || targetCell.innerText.trim() === "" || targetCell.innerText.trim() === "Empty";

                if (id && originalText && isEmpty && !translationMap.has(id)) {
                    console.log(`[–°–±–æ—Ä] ID: ${id} | EN: "${originalText.substring(0, 30)}..."`);
                    translationMap.set(id, { id: id, original: originalText, translation: '' });
                }
            }

            startBtn.innerHTML = `üì° –°–±–æ—Ä: ${translationMap.size}`;
            window.scrollBy(0, window.innerHeight);
            await new Promise(r => setTimeout(r, CONFIG.SCROLL_DELAY));
            let h = document.body.scrollHeight;
            if (h === lastHeight) sameHeightCount++; else sameHeightCount = 0;
            lastHeight = h;
        }
        window.scrollTo(0, 0);
        return true;
    }

    async function translateWithGemini() {
        if (isStopped) return false;
        startBtn.innerHTML = '‚è≥ Gemini...';
        
        const payload = Array.from(translationMap.values()).map(item => ({
            id: item.id,
            text: item.original
        }));

        const prompt = `Role: Act as a professional translator and Polish localization expert. Your task is to translate video scripts from English to Polish.

Context: This is business/personal development coaching, meditations, sports lessons, psychology podcasts.
Style: Natural "living" language. Focus on flow.
Be aware of this rule in polish grammar: W tym zdaniu jest imies≈Ç√≥w przys≈Ç√≥wkowy pozostawiajƒÖc, ale nie ma czasownika –≤ —Ñ—É–Ω–∫—Ü–∏–∏ orzeczenia. Mo≈ºliwe, ≈ºe to tytu–ª, ale –≤ takim razie zbƒôd–Ω–∞ jest kropka.
Check the name of the speaker and make a research: if it's a man or a woman.
Grammar: If the speaker is a woman:
  1. Use feminine verb forms (e.g., "zrobi≈Çam", "powiedzia≈Çam").
  2. Use feminatives (e.g., "trenerka", "ekspertka"), where needed.

IMPORTANT: Respond ONLY with a valid JSON object.
Structure: {"results": [{"id": "ID_HERE", "translation": "POLISH_TEXT_HERE"}, ...]}

Data to translate: ${JSON.stringify(payload)}`;

        try {
            const resp = await fetchGemini(prompt);
            console.log("%c[API RESPONSE]:", "color: #7b1fa2; font-weight: bold;", resp);

            const first = resp.indexOf('{'), last = resp.lastIndexOf('}');
            const data = JSON.parse(resp.substring(first, last + 1));
            const results = data.results;

            if (!Array.isArray(results)) throw new Error("Format error");

            results.forEach(res => {
                if (translationMap.has(res.id)) {
                    translationMap.get(res.id).translation = res.translation;
                }
            });
            return true;
        } catch (e) { 
            console.error("‚ùå API Error:", e); 
            return false; 
        }
    }

    async function fillTranslations() {
        const items = Array.from(translationMap.values());
        for (let i = 0; i < items.length; i++) {
            if (isStopped) return;
            const data = items[i];
            if (!data.translation) continue;

            startBtn.innerHTML = `‚úçÔ∏è ${i+1}/${items.length}`;
            let row = document.querySelector(`.row-key[data-id="${data.id}"]`);
            
            let attempts = 0;
            while (!row && attempts < 10) {
                if (isStopped) return;
                window.scrollBy(0, 400);
                await new Promise(r => setTimeout(r, 300));
                row = document.querySelector(`.row-key[data-id="${data.id}"]`);
                attempts++;
            }
            if (row) {
                await inputProcess(row, data.translation, data.id);
                await new Promise(r => setTimeout(r, CONFIG.ROW_NEXT_DELAY));
            }
        }
    }

    async function inputProcess(row, text, id) {
        const targetCell = row.querySelector(`.cell-trans[data-lang-id="${CONFIG.TARGET_LANG_ID}"] .highlight`);
        if (!targetCell) return;

        targetCell.click();
        await new Promise(r => setTimeout(r, CONFIG.EDITOR_LOAD_DELAY));

        let editor = document.querySelector('.ace_text-input, textarea:not([style*="display: none"]), [contenteditable="true"]');

        if (editor) {
            editor.focus();
            editor.click();
            await new Promise(r => setTimeout(r, CONFIG.FOCUS_DELAY));

            // –ü—Ä—è–º–∞—è –≤—Å—Ç–∞–≤–∫–∞ –±–µ–∑ –æ—á–∏—Å—Ç–∫–∏
            console.log(`   [ID ${id}] –í—Å—Ç–∞–≤–∫–∞: "${text.substring(0, 30)}..."`);
            document.execCommand('insertText', false, text);

            if (!editor.value && !editor.innerText) {
                editor.value = text;
                editor.dispatchEvent(new Event('input', { bubbles: true }));
            }

            editor.dispatchEvent(new Event('change', { bubbles: true }));
            await new Promise(r => setTimeout(r, CONFIG.BEFORE_SAVE_DELAY));

            const saveBtn = document.querySelector('button.save.btn-primary');
            if (saveBtn) {
                saveBtn.click();
            } else {
                const modifier = isMac ? { metaKey: true } : { ctrlKey: true };
                editor.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', ...modifier, bubbles: true }));
            }

            for(let i=0; i<15; i++) {
                const stillOpen = document.querySelector('.ace_text-input, textarea:not([style*="display: none"])');
                if (!stillOpen) {
                    console.log(`‚úÖ ID ${id} —Å–æ—Ö—Ä–∞–Ω–µ–Ω.`);
                    return;
                }
                await new Promise(r => setTimeout(r, CONFIG.SAVE_CHECK_DELAY));
            }
            row.querySelector('.non-editable-key-name')?.click();
        }
    }

    function fetchGemini(prompt) {
        const url = `https://generativelanguage.googleapis.com/v1/models/${CONFIG.MODEL}:generateContent?key=${CONFIG.GEMINI_API_KEY}`;
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: "POST",
                url: url,
                headers: { "Content-Type": "application/json" },
                data: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                onload: (res) => {
                    const r = JSON.parse(res.responseText);
                    if (res.status !== 200) reject(r.error?.message || "Error");
                    else resolve(r.candidates[0].content.parts[0].text);
                },
                onerror: () => reject("Network error")
            });
        });
    }
})();
