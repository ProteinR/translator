// ==UserScript==
// @name         Lokalise Auto-Translator (Gemini Fix URL)
// @namespace    http://tampermonkey.net/
// @version      1.9
// @grant        GM_xmlhttpRequest
// @connect      generativelanguage.googleapis.com
// @match        https://app.lokalise.com/project/*
// ==/UserScript==

// ============================================================
// 1. –í–ê–® –ö–û–ù–§–ò–ì
// ============================================================
function getScriptConfig() {
    return {
        GEMINI_API_KEY: '',
        TARGET_LANG_ID: '748',
        SOURCE_LANG_ID: '640',
        MODEL: "gemini-2.5-flash", // –µ—Å–ª–∏ –Ω–µ –∑–∞—Ä–∞–±–æ—Ç–∞–µ—Ç, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ "gemini-pro"
        SCROLL_DELAY: 1500,
        DEBUG_MODE: true,
    };
}
// ============================================================
// –ö–û–ù–ï–¶ –ö–û–ù–§–ò–ì–ê
// ============================================================


(function() {
    'use strict';

    const CONFIG = getScriptConfig();
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    let translationMap = new Map();
    let isStopped = false;

    // –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    const container = document.createElement('div');
    container.style = 'position:fixed;top:10px;right:10px;z-index:9999;display:flex;gap:5px;';
    document.body.appendChild(container);

    const startBtn = document.createElement('button');
    startBtn.innerHTML = 'üöÄ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–≤–æ–¥–∞';
    startBtn.style = 'padding:10px;background:#1a73e8;color:#fff;border:none;border-radius:5px;cursor:pointer;font-weight:bold;';

    const stopBtn = document.createElement('button');
    stopBtn.innerHTML = 'üõë Stop';
    stopBtn.style = 'padding:10px;background:#dc3545;color:#fff;border:none;border-radius:5px;cursor:pointer;font-weight:bold;display:none;';

    container.appendChild(startBtn);
    container.appendChild(stopBtn);

    stopBtn.onclick = () => { isStopped = true; console.warn("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞..."); };

    startBtn.onclick = async () => {
        console.log(`%c--- –ó–ê–ü–£–°–ö 3.2 [DEBUG: ${CONFIG.DEBUG_MODE}] ---`, "color: #1a73e8; font-weight: bold;");
        isStopped = false;
        startBtn.disabled = true;
        stopBtn.style.display = 'block';
        translationMap.clear();

        try {
            if (!(await scrollAndCollect()) || isStopped) return;
            if (!(await translateWithGemini()) || isStopped) return;
            await fillTranslations();
            console.log("%c--- –í–°–Å –ó–ê–í–ï–†–®–ï–ù–û ---", "color: green; font-weight: bold;");
        } catch (err) {
            console.error(`‚ùå –û—à–∏–±–∫–∞: ${err}`);
        } finally {
            startBtn.disabled = false;
            startBtn.innerHTML = 'üöÄ Start Automation';
            stopBtn.style.display = 'none';
        }
    };

    async function scrollAndCollect() {
        let lastHeight = 0;
        let sameHeightCount = 0;
        while (sameHeightCount < 3) {
            if (isStopped) return false;
            const rows = document.querySelectorAll('.row-key[data-id]');
            for (let row of rows) {
                const id = row.getAttribute('data-id');
                const originalText = row.querySelector(`.base-cell-trans .highlight`)?.innerText;
                if (id && originalText && !translationMap.has(id)) {
                    if (CONFIG.DEBUG_MODE && translationMap.size >= 15) {
                        window.scrollTo(0, 0);
                        return true;
                    }
                    translationMap.set(id, { original: originalText, translation: '' });
                }
            }
            startBtn.innerHTML = `üì° –°–±–æ—Ä: ${translationMap.size}`;
            window.scrollBy(0, window.innerHeight);
            await new Promise(r => setTimeout(r, CONFIG.SCROLL_DELAY));
            let h = document.body.scrollHeight;
            if (h === lastHeight) sameHeightCount++; else sameHeightCount = 0;
            lastHeight = h;
        }
        window.scrollTo(0, 0);
        return true;
    }

    async function translateWithGemini() {
        if (isStopped) return false;
        startBtn.innerHTML = '‚è≥ Gemini is localizing...';
        const entries = Array.from(translationMap.entries());
        const texts = entries.map(e => e[1].original);

        console.log(`[API] –û—Ç–ø—Ä–∞–≤–∫–∞ ${texts.length} —Å—Ç—Ä–æ–∫ —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º...`);

        // –§–æ—Ä–º–∏—Ä—É–µ–º –¥–µ—Ç–∞–ª—å–Ω—ã–π –ø—Ä–æ–º–ø—Ç
        const prompt = `Role: Act as a professional translator and Polish localization expert. Your task is to translate video scripts from English to Polish.

Context: This is business/personal development coaching, meditations, sports lessons, psychology podcasts ‚Äì use professional but accessible terminology.

Style:
- Translate naturally using "living" language used by a Native Speaker (avoid stiff, machine-like constructions).
- Focus on flow and clarity suitable for audio/video narration.

Grammar & Speaker Identity (Crucial):
- Pay strict attention to grammatical correctness: check verb aspects, tenses, and declension endings.
- Identify the gender of the speaker/narrator. If the speaker is a woman:
  1. Use feminine verb forms (e.g., "zrobi≈Çam", "powiedzia≈Çam").
  2. Use appropriate feminine forms for professions and roles (feminatives) instead of generic masculine ones (e.g., use "trenerka", "ekspertka").

IMPORTANT: You MUST respond ONLY with a valid JSON object.
Structure: {"translations": ["translated_string_1", "translated_string_2", ...]}
The order of the translations must match the input array exactly. No conversational text or markdown blocks.

Texts to translate: ${JSON.stringify(texts)}`;

        try {
            const resp = await fetchGemini(prompt);

            // –õ–æ–≥–∏—Ä—É–µ–º —Å—ã—Ä–æ–π –æ—Ç–≤–µ—Ç –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è –∫–∞—á–µ—Å—Ç–≤–∞ –ø–µ—Ä–µ–≤–æ–¥–∞
            console.log("%c[API RAW RESPONSE]:", "color: #7b1fa2; font-weight: bold;", resp);

            const first = resp.indexOf('{');
            const last = resp.lastIndexOf('}');
            const data = JSON.parse(resp.substring(first, last + 1));
            const list = data.translations;

            if (!Array.isArray(list)) throw new Error("Response field 'translations' is not an array");

            entries.forEach((e, i) => {
                translationMap.get(e[0]).translation = list[i] || '';
            });

            console.log("%c[API] –ü–µ—Ä–µ–≤–æ–¥—ã —É—Å–ø–µ—à–Ω–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω—ã —Å ID.", "color: green;");
            return true;
        } catch (e) {
            console.error("‚ùå API Error:", e);
            alert("–û—à–∏–±–∫–∞ Gemini: " + e.message);
            return false;
        }
    }

    async function fillTranslations() {
        const ids = Array.from(translationMap.keys());
        for (let i = 0; i < ids.length; i++) {
            if (isStopped) return;
            const id = ids[i];
            const data = translationMap.get(id);

            startBtn.innerHTML = `‚úçÔ∏è ${i+1}/${ids.length}`;
            console.log(`[ID ${id}] –í—Å—Ç–∞–≤–∫–∞: "${data.translation.substring(0, 30)}..."`);

            let row = document.querySelector(`.row-key[data-id="${id}"]`);
            let attempts = 0;

            // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ —Å—Ç—Ä–æ–∫–∏ –ø—Ä–∏ —Å–∫—Ä–æ–ª–ª–µ
            while (!row && attempts < 10) {
                if (isStopped) return;
                window.scrollBy(0, 400);
                await new Promise(r => setTimeout(r, 250));
                row = document.querySelector(`.row-key[data-id="${id}"]`);
                attempts++;
            }

            if (row) {
                // –í—ã–∑—ã–≤–∞–µ–º –º–µ—Ç–æ–¥ –≤–≤–æ–¥–∞ –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –≤–µ—Ä—Å–∏–π (—Å –æ—á–∏—Å—Ç–∫–æ–π –∏ Save)
                await inputProcess(row, data.translation, id);
                // –ö–æ—Ä–æ—Ç–∫–∞—è –ø–∞—É–∑–∞ –º–µ–∂–¥—É —Å—Ç—Ä–æ–∫–∞–º–∏ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ Lokalise
                await new Promise(r => setTimeout(r, 500));
            } else {
                console.warn(`[!] –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≤ DOM —Å—Ç—Ä–æ–∫—É —Å ID ${id}`);
            }
        }
    }

    async function inputProcess(row, text, id) {
        const targetCell = row.querySelector(`.cell-trans[data-lang-id="${CONFIG.TARGET_LANG_ID}"] .highlight`);
        if (!targetCell) return;

        console.log(`[ID ${id}] –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ...`);
        targetCell.click();
        await new Promise(r => setTimeout(r, 1200));

        let editor = document.querySelector('.ace_text-input, textarea:not([style*="display: none"]), [contenteditable="true"]');

        if (editor) {
            editor.focus();
            editor.click(); // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–ª–∏–∫ –≤–Ω—É—Ç—Ä—å –¥–ª—è —Ñ–æ–∫—É—Å–∞
            await new Promise(r => setTimeout(r, 200));

            const modifier = isMac ? { metaKey: true } : { ctrlKey: true };

            // 1. –ü–û–ü–´–¢–ö–ê –í–´–î–ï–õ–ò–¢–¨ –í–°–Å (–ö–õ–ê–í–ò–®–ê–ú–ò)
            console.log("   -> –°–∏–º—É–ª—è—Ü–∏—è Select All...");
            editor.dispatchEvent(new KeyboardEvent('keydown', { key: 'a', code: 'KeyA', keyCode: 65, which: 65, ...modifier, bubbles: true }));
            document.execCommand('selectAll', false, null);
            await new Promise(r => setTimeout(r, 100));

            // 2. –ü–û–ü–´–¢–ö–ê –£–î–ê–õ–ò–¢–¨ (BACKSPACE)
            console.log("   -> –°–∏–º—É–ª—è—Ü–∏—è Backspace...");
            editor.dispatchEvent(new KeyboardEvent('keydown', { key: 'Backspace', code: 'Backspace', keyCode: 8, which: 8, bubbles: true }));
            document.execCommand('delete', false, null);

            // –°–ò–õ–û–í–û–ï –û–ë–ù–£–õ–ï–ù–ò–ï (–µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥—ã –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏)
            if (editor.value) editor.value = '';
            if (editor.innerText) editor.innerText = '';
            editor.dispatchEvent(new Event('input', { bubbles: true }));

            await new Promise(r => setTimeout(r, 200));

            // 3. –í–°–¢–ê–í–ö–ê
            console.log(`   -> –í—Å—Ç–∞–≤–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞...`);
            document.execCommand('insertText', false, text);

            // –ï—Å–ª–∏ –≤—Å—ë –µ—â–µ –ø—É—Å—Ç–æ
            if (!editor.value && !editor.innerText) {
                editor.value = text;
                editor.dispatchEvent(new Event('input', { bubbles: true }));
            }

            // –£–≤–µ–¥–æ–º–ª—è–µ–º —Å–∏—Å—Ç–µ–º—É –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
            editor.dispatchEvent(new Event('change', { bubbles: true }));
            await new Promise(r => setTimeout(r, 600));

            // 4. –°–û–•–†–ê–ù–ï–ù–ò–ï
            const saveBtn = document.querySelector('button.save.btn-primary');
            if (saveBtn) {
                console.log("   -> –ù–∞–∂–∞—Ç–∏–µ SAVE");
                saveBtn.click();
            } else {
                editor.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', ...modifier, bubbles: true }));
            }

            // –ñ–¥–µ–º –∑–∞–∫—Ä—ã—Ç–∏—è
            for(let i=0; i<15; i++) {
                const stillOpen = document.querySelector('.ace_text-input, textarea:not([style*="display: none"])');
                if (!stillOpen) {
                    console.log(`‚úÖ ID ${id} —Å–æ—Ö—Ä–∞–Ω–µ–Ω.`);
                    return;
                }
                await new Promise(r => setTimeout(r, 150));
            }
            row.querySelector('.non-editable-key-name')?.click();
        }
    }

    function fetchGemini(prompt) {
        const url = `https://generativelanguage.googleapis.com/v1/models/${CONFIG.MODEL}:generateContent?key=${CONFIG.GEMINI_API_KEY}`;
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: "POST",
                url: url,
                headers: { "Content-Type": "application/json" },
                data: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                onload: (res) => {
                    const r = JSON.parse(res.responseText);
                    if (res.status !== 200) reject(r.error?.message || "Error");
                    else resolve(r.candidates[0].content.parts[0].text);
                },
                onerror: () => reject("Network error")
            });
        });
    }
})();
