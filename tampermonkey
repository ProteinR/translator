// ==UserScript==
// @name         Lokalise Auto-Translator (Gemini 3.4 - Custom Delays & No Clear)
// @namespace    http://tampermonkey.net/
// @version      3.4
// @grant        GM_xmlhttpRequest
// @connect      generativelanguage.googleapis.com
// @match        https://app.lokalise.com/project/*
// ==/UserScript==

// ============================================================
// 1. –í–ê–® –ö–û–ù–§–ò–ì
// ============================================================
function getScriptConfig() {
    return {
        GEMINI_API_KEY: '',
        TARGET_LANG_ID: '748',
        SOURCE_LANG_ID: '640',
        MODEL: "gemini-2.5-flash", 
        DEBUG_MODE: false,               // TRUE - —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 15 –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫
        
        // --- –ó–ê–î–ï–†–ñ–ö–ò (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö) ---
        SCROLL_DELAY: 2000,              // –ü–∞—É–∑–∞ –ø—Ä–∏ —Å–∫—Ä–æ–ª–ª–∏–Ω–≥–µ
        EDITOR_LOAD_DELAY: 1200,         // –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ –ø–æ—Å–ª–µ –∫–ª–∏–∫–∞
        FOCUS_DELAY: 200,                // –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ —Ñ–æ–∫—É—Å–∞ –≤ –ø–æ–ª–µ
        BEFORE_SAVE_DELAY: 600,          // –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –Ω–∞–∂–∞—Ç–∏–µ–º –∫–Ω–æ–ø–∫–∏ Save
        SAVE_CHECK_DELAY: 150,           // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
        ROW_NEXT_DELAY: 500              // –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ö–æ–¥–æ–º –∫ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–µ
    };
}
// ============================================================
// –ö–û–ù–ï–¶ –ö–û–ù–§–ò–ì–ê
// ============================================================

(function() {
    'use strict';

    const CONFIG = getScriptConfig();
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    let translationMap = new Map();
    let isStopped = false;

    // –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    const container = document.createElement('div');
    container.style = 'position:fixed;top:10px;right:10px;z-index:9999;display:flex;gap:5px;';
    document.body.appendChild(container);

    const startBtn = document.createElement('button');
    startBtn.innerHTML = 'üöÄ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–≤–æ–¥–∞';
    startBtn.style = 'padding:10px;background:#1a73e8;color:#fff;border:none;border-radius:5px;cursor:pointer;font-weight:bold;';

    const stopBtn = document.createElement('button');
    stopBtn.innerHTML = 'üõë Stop';
    stopBtn.style = 'padding:10px;background:#dc3545;color:#fff;border:none;border-radius:5px;cursor:pointer;font-weight:bold;display:none;';

    container.appendChild(startBtn);
    container.appendChild(stopBtn);

    stopBtn.onclick = () => { isStopped = true; console.warn("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞..."); };

    startBtn.onclick = async () => {
        console.log(`%c--- –ó–ê–ü–£–°–ö 3.4 [RESUME MODE, DEBUG: ${CONFIG.DEBUG_MODE}] ---`, "color: #1a73e8; font-weight: bold;");
        isStopped = false;
        startBtn.disabled = true;
        stopBtn.style.display = 'block';
        translationMap.clear();

        try {
            if (!(await scrollAndCollect()) || isStopped) return;

            if (translationMap.size === 0) {
                console.log("%c--- –í–°–ï –ü–ï–†–ï–í–ï–î–ï–ù–û (–ü—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ) ---", "color: green; font-weight: bold;");
                return;
            }

            if (!(await translateWithGemini()) || isStopped) return;
            await fillTranslations();
            console.log("%c--- –í–°–Å –ó–ê–í–ï–†–®–ï–ù–û ---", "color: green; font-weight: bold;");
        } catch (err) {
            console.error(`‚ùå –û—à–∏–±–∫–∞: ${err}`);
        } finally {
            startBtn.disabled = false;
            startBtn.innerHTML = 'üöÄ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–≤–æ–¥–∞';
            stopBtn.style.display = 'none';
        }
    };

    async function scrollAndCollect() {
        let lastHeight = 0;
        let sameHeightCount = 0;
        while (sameHeightCount < 3) {
            if (isStopped) return false;
            const rows = document.querySelectorAll('.row-key[data-id]');

            for (let row of rows) {
                const id = row.getAttribute('data-id');
                const originalText = row.querySelector(`.base-cell-trans .highlight`)?.innerText;

                const targetCell = row.querySelector(`.cell-trans[data-lang-id="${CONFIG.TARGET_LANG_ID}"] .highlight`);
                const isEmpty = !targetCell || targetCell.querySelector('.empty') || targetCell.innerText.trim() === "" || targetCell.innerText.trim() === "Empty";

                if (id && originalText && isEmpty && !translationMap.has(id)) {
                    if (CONFIG.DEBUG_MODE && translationMap.size >= 15) {
                        window.scrollTo(0, 0);
                        return true;
                    }
                    console.log(`[–°–±–æ—Ä] ID: ${id} (–ü—É—Å—Ç–æ–π) | EN: "${originalText.substring(0, 30)}..."`);
                    translationMap.set(id, { original: originalText, translation: '' });
                }
            }

            startBtn.innerHTML = `üì° –°–±–æ—Ä –ø—É—Å—Ç—ã—Ö: ${translationMap.size}`;
            window.scrollBy(0, window.innerHeight);
            await new Promise(r => setTimeout(r, CONFIG.SCROLL_DELAY));
            let h = document.body.scrollHeight;
            if (h === lastHeight) sameHeightCount++; else sameHeightCount = 0;
            lastHeight = h;
        }
        window.scrollTo(0, 0);
        return true;
    }

    async function translateWithGemini() {
        if (isStopped) return false;
        startBtn.innerHTML = '‚è≥ Gemini is localizing...';
        const entries = Array.from(translationMap.entries());
        const texts = entries.map(e => e[1].original);

        console.log(`[API] –û—Ç–ø—Ä–∞–≤–∫–∞ ${texts.length} –ø—É—Å—Ç—ã—Ö —Å—Ç—Ä–æ–∫ –≤ Gemini...`);

        // –¢–í–û–ô –ü–†–û–ú–ü–¢ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
        const prompt = `Role: Act as a professional translator and Polish localization expert. Your task is to translate video scripts from English to Polish.

Context: This is business/personal development coaching, meditations, sports lessons, psychology podcasts.
Style: Natural "living" language. Focus on flow.
Be aware of this rule in polish grammar: W tym zdaniu jest imies≈Ç√≥w przys≈Ç√≥wkowy pozostawiajƒÖc, ale nie ma czasownika –≤ —Ñ—É–Ω–∫—Ü–∏–∏ orzeczenia. Mo≈ºliwe, ≈ºe to tytu–ª, ale –≤ takim razie zbƒôdna jest kropka.
Check the name of the speaker and make a research: if it's a man or a woman.
Grammar: If the speaker is a woman:
  1. Use feminine verb forms (e.g., "zrobi≈Çam", "powiedzia≈Çam").
  2. Use feminatives (e.g., "trenerka", "ekspertka"), where needed.

IMPORTANT: Respond ONLY with a valid JSON object.
Structure: {"translations": ["translated_string_1", "translated_string_2", ...]}
Order must match the input array exactly.

Texts to translate: ${JSON.stringify(texts)}`;

        try {
            const resp = await fetchGemini(prompt);
            console.log("%c[API RAW RESPONSE]:", "color: #7b1fa2; font-weight: bold;", resp);

            const first = resp.indexOf('{'), last = resp.lastIndexOf('}');
            const data = JSON.parse(resp.substring(first, last + 1));
            const list = data.translations;

            if (!Array.isArray(list)) throw new Error("Field 'translations' is not an array");

            entries.forEach((e, i) => {
                translationMap.get(e[0]).translation = list[i] || '';
            });

            console.log("%c[API] –ü–µ—Ä–µ–≤–æ–¥—ã –ø–æ–ª—É—á–µ–Ω—ã –∏ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω—ã.", "color: green;");
            return true;
        } catch (e) { 
            console.error("‚ùå API Error:", e); 
            return false; 
        }
    }

    async function fillTranslations() {
        const ids = Array.from(translationMap.keys());
        for (let i = 0; i < ids.length; i++) {
            if (isStopped) return;
            const id = ids[i];
            const data = translationMap.get(id);
            startBtn.innerHTML = `‚úçÔ∏è ${i+1}/${ids.length}`;

            let row = document.querySelector(`.row-key[data-id="${id}"]`);
            let attempts = 0;
            while (!row && attempts < 10) {
                if (isStopped) return;
                window.scrollBy(0, 400);
                await new Promise(r => setTimeout(r, 300));
                row = document.querySelector(`.row-key[data-id="${id}"]`);
                attempts++;
            }
            if (row) {
                await inputProcess(row, data.translation, id);
                await new Promise(r => setTimeout(r, CONFIG.ROW_NEXT_DELAY));
            }
        }
    }

    async function inputProcess(row, text, id) {
        const targetCell = row.querySelector(`.cell-trans[data-lang-id="${CONFIG.TARGET_LANG_ID}"] .highlight`);
        if (!targetCell) return;

        console.log(`[ID ${id}] –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ...`);
        targetCell.click();
        await new Promise(r => setTimeout(r, CONFIG.EDITOR_LOAD_DELAY));

        let editor = document.querySelector('.ace_text-input, textarea:not([style*="display: none"]), [contenteditable="true"]');

        if (editor) {
            editor.focus();
            editor.click();
            await new Promise(r => setTimeout(r, CONFIG.FOCUS_DELAY));

            // –í–°–¢–ê–í–ö–ê (–û–ß–ò–°–¢–ö–ê –£–î–ê–õ–ï–ù–ê –ü–û –ó–ê–ü–†–û–°–£)
            console.log(`   -> –í—Å—Ç–∞–≤–ª—è—é: "${text.substring(0, 30)}..."`);
            document.execCommand('insertText', false, text);

            if (!editor.value && !editor.innerText) {
                editor.value = text;
                editor.dispatchEvent(new Event('input', { bubbles: true }));
            }

            editor.dispatchEvent(new Event('change', { bubbles: true }));
            await new Promise(r => setTimeout(r, CONFIG.BEFORE_SAVE_DELAY));

            // –°–û–•–†–ê–ù–ï–ù–ò–ï
            const saveBtn = document.querySelector('button.save.btn-primary');
            if (saveBtn) {
                saveBtn.click();
            } else {
                const modifier = isMac ? { metaKey: true } : { ctrlKey: true };
                editor.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', ...modifier, bubbles: true }));
            }

            // –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–∏—è
            for(let i=0; i<15; i++) {
                const stillOpen = document.querySelector('.ace_text-input, textarea:not([style*="display: none"])');
                if (!stillOpen) {
                    console.log(`‚úÖ ID ${id} —Å–æ—Ö—Ä–∞–Ω–µ–Ω.`);
                    return;
                }
                await new Promise(r => setTimeout(r, CONFIG.SAVE_CHECK_DELAY));
            }
            row.querySelector('.non-editable-key-name')?.click();
        }
    }

    function fetchGemini(prompt) {
        const url = `https://generativelanguage.googleapis.com/v1/models/${CONFIG.MODEL}:generateContent?key=${CONFIG.GEMINI_API_KEY}`;
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: "POST",
                url: url,
                headers: { "Content-Type": "application/json" },
                data: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                onload: (res) => {
                    const r = JSON.parse(res.responseText);
                    if (res.status !== 200) reject(r.error?.message || "Error");
                    else resolve(r.candidates[0].content.parts[0].text);
                },
                onerror: () => reject("Network error")
            });
        });
    }
})();
