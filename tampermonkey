// ==UserScript==
// @name         Lokalise Auto-Translator (Gemini 2.5-Flash + ID Mapping)
// @namespace    http://tampermonkey.net/
// @version      3.5
// @grant        GM_xmlhttpRequest
// @connect      generativelanguage.googleapis.com
// @match        https://app.lokalise.com/project/*
// ==/UserScript==

// ============================================================
// 1. –í–ê–® –ö–û–ù–§–ò–ì
// ============================================================
function getScriptConfig() {
    return {
        GEMINI_API_KEY: '',
        TARGET_LANG_ID: '748',
        SOURCE_LANG_ID: '640',
        MODEL: "gemini-2.5-flash", 
        DEBUG_MODE: false,

        // --- –ó–ê–î–ï–†–ñ–ö–ò (–≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö) ---
        SCROLL_DELAY: 2000,          // –ü–∞—É–∑–∞ –ø—Ä–∏ —Å–∫—Ä–æ–ª–ª–∏–Ω–≥–µ
        EDITOR_LOAD_DELAY: 1500,     // –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ –ø–æ—Å–ª–µ –∫–ª–∏–∫–∞
        FOCUS_DELAY: 300,            // –ü–∞—É–∑–∞ –ø–æ—Å–ª–µ —Ñ–æ–∫—É—Å–∞ –≤ –ø–æ–ª–µ
        BEFORE_SAVE_DELAY: 800,      // –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –Ω–∞–∂–∞—Ç–∏–µ–º –∫–Ω–æ–ø–∫–∏ Save
        SAVE_CHECK_DELAY: 200,       // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
        ROW_NEXT_DELAY: 600          // –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ö–æ–¥–æ–º –∫ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–µ
    };
}
// ============================================================
// –ö–û–ù–ï–¶ –ö–û–ù–§–ò–ì–ê
// ============================================================

(function() {
    'use strict';

    const CONFIG = getScriptConfig();
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    let translationMap = new Map(); 
    let isStopped = false;

    // –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    const container = document.createElement('div');
    container.style = 'position:fixed;top:10px;right:10px;z-index:9999;display:flex;gap:5px;';
    document.body.appendChild(container);

    const startBtn = document.createElement('button');
    startBtn.innerHTML = 'üöÄ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–≤–æ–¥–∞';
    startBtn.style = 'padding:10px;background:#1a73e8;color:#fff;border:none;border-radius:5px;cursor:pointer;font-weight:bold;';

    const stopBtn = document.createElement('button');
    stopBtn.innerHTML = 'üõë Stop';
    stopBtn.style = 'padding:10px;background:#dc3545;color:#fff;border:none;border-radius:5px;cursor:pointer;font-weight:bold;display:none;';

    container.appendChild(startBtn);
    container.appendChild(stopBtn);

    stopBtn.onclick = () => { isStopped = true; console.warn("üõë –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é..."); };

    startBtn.onclick = async () => {
        console.log(`%c--- –ó–ê–ü–£–°–ö 3.5 [MODEL: ${CONFIG.MODEL}] ---`, "color: #1a73e8; font-weight: bold;");
        isStopped = false;
        startBtn.disabled = true;
        stopBtn.style.display = 'block';
        translationMap.clear();

        try {
            if (!(await scrollAndCollect()) || isStopped) return;

            if (translationMap.size === 0) {
                console.log("%c--- –í–°–ï –ü–ï–†–ï–í–ï–î–ï–ù–û ---", "color: green; font-weight: bold;");
                return;
            }

            if (!(await translateWithGemini()) || isStopped) return;
            await fillTranslations();
            console.log("%c--- –í–°–Å –ó–ê–í–ï–†–®–ï–ù–û ---", "color: green; font-weight: bold;");
        } catch (err) {
            console.error(`‚ùå –û—à–∏–±–∫–∞: ${err}`);
        } finally {
            startBtn.disabled = false;
            startBtn.innerHTML = 'üöÄ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–µ–≤–æ–¥–∞';
            stopBtn.style.display = 'none';
        }
    };

    async function scrollAndCollect() {
        let lastHeight = 0;
        let sameHeightCount = 0;
        while (sameHeightCount < 3) {
            if (isStopped) return false;
            const rows = document.querySelectorAll('.row-key[data-id]');

            for (let row of rows) {
                const id = row.getAttribute('data-id');
                const originalText = row.querySelector(`.base-cell-trans .highlight`)?.innerText;
                const targetCell = row.querySelector(`.cell-trans[data-lang-id="${CONFIG.TARGET_LANG_ID}"] .highlight`);
                const isEmpty = !targetCell || targetCell.querySelector('.empty') || targetCell.innerText.trim() === "" || targetCell.innerText.trim() === "Empty";

                if (id && originalText && isEmpty && !translationMap.has(id)) {
                    if (CONFIG.DEBUG_MODE && translationMap.size >= 15) {
                        window.scrollTo(0, 0);
                        return true;
                    }
                    console.log(`[–°–±–æ—Ä] ID: ${id} | EN: "${originalText.substring(0, 30)}..."`);
                    translationMap.set(id, { id: id, original: originalText, translation: '' });
                }
            }

            startBtn.innerHTML = `üì° –°–±–æ—Ä –ø—É—Å—Ç—ã—Ö: ${translationMap.size}`;
            window.scrollBy(0, window.innerHeight);
            await new Promise(r => setTimeout(r, CONFIG.SCROLL_DELAY));
            let h = document.body.scrollHeight;
            if (h === lastHeight) sameHeightCount++; else sameHeightCount = 0;
            lastHeight = h;
        }
        window.scrollTo(0, 0);
        return true;
    }

    async function translateWithGemini() {
        if (isStopped) return false;
        startBtn.innerHTML = '‚è≥ Gemini translating...';
        
        const payload = Array.from(translationMap.values()).map(item => ({
            id: item.id,
            text: item.original
        }));

        console.log(`[API] –û—Ç–ø—Ä–∞–≤–∫–∞ ${payload.length} –æ–±—ä–µ–∫—Ç–æ–≤ –≤ ${CONFIG.MODEL}...`);

        const prompt = `Role: Act as a professional translator and Polish localization expert. Your task is to translate video scripts from English to Polish.

Context: This is business/personal development coaching, meditations, sports lessons, psychology podcasts.
Style: Natural "living" language. Focus on flow.
Be aware of this rule in polish grammar: W tym zdaniu jest imies≈Ç√≥w przys≈Ç√≥wkowy pozostawiajƒÖc, ale nie ma czasownika –≤ —Ñ—É–Ω–∫—Ü–∏–∏ orzeczenia. Mo≈ºliwe, ≈ºe to tytu–ª, ale –≤ takim razie zbƒôd–Ω–∞ jest kropka.
Check the name of the speaker and make a research: if it's a man or a woman.
Grammar: If the speaker is a woman:
  1. Use feminine verb forms (e.g., "zrobi≈Çam", "powiedzia≈Çam").
  2. Use feminatives (e.g., "trenerka", "ekspertka"), where needed.

IMPORTANT: Respond ONLY with a valid JSON object.
Structure: {"results": [{"id": "ID_HERE", "translation": "POLISH_TEXT_HERE"}, ...]}

Data to translate: ${JSON.stringify(payload)}`;

        try {
            const resp = await fetchGemini(prompt);
            console.log("%c[API RAW RESPONSE]:", "color: #7b1fa2; font-weight: bold;", resp);

            const first = resp.indexOf('{'), last = resp.lastIndexOf('}');
            const data = JSON.parse(resp.substring(first, last + 1));
            const results = data.results;

            if (!Array.isArray(results)) throw new Error("Field 'results' is not an array");

            results.forEach(res => {
                if (translationMap.has(res.id)) {
                    translationMap.get(res.id).translation = res.translation;
                    console.log(`[–ú–∞—Ç—á–∏–Ω–≥] ID ${res.id} matched.`);
                }
            });

            return true;
        } catch (e) { 
            console.error("‚ùå API Error:", e); 
            return false; 
        }
    }

    async function fillTranslations() {
        const items = Array.from(translationMap.values());
        for (let i = 0; i < items.length; i++) {
            if (isStopped) return;
            const data = items[i];
            if (!data.translation) continue;

            startBtn.innerHTML = `‚úçÔ∏è ${i+1}/${items.length}`;
            let row = document.querySelector(`.row-key[data-id="${data.id}"]`);
            
            let attempts = 0;
            while (!row && attempts < 10) {
                if (isStopped) return;
                window.scrollBy(0, 400);
                await new Promise(r => setTimeout(r, 300));
                row = document.querySelector(`.row-key[data-id="${data.id}"]`);
                attempts++;
            }
            if (row) {
                await inputProcess(row, data.translation, data.id);
                await new Promise(r => setTimeout(r, CONFIG.ROW_NEXT_DELAY));
            }
        }
    }

    async function inputProcess(row, text, id) {
        const targetCell = row.querySelector(`.cell-trans[data-lang-id="${CONFIG.TARGET_LANG_ID}"] .highlight`);
        if (!targetCell) return;

        targetCell.click();
        await new Promise(r => setTimeout(r, CONFIG.EDITOR_LOAD_DELAY));

        let editor = document.querySelector('.ace_text-input, textarea:not([style*="display: none"]), [contenteditable="true"]');

        if (editor) {
            editor.focus();
            editor.click();
            await new Promise(r => setTimeout(r, CONFIG.FOCUS_DELAY));

            // –í–°–¢–ê–í–ö–ê –ë–ï–ó –û–ß–ò–°–¢–ö–ò
            console.log(`   [ID ${id}] –ü–∏—à—É: "${text.substring(0, 30)}..."`);
            document.execCommand('insertText', false, text);

            if (!editor.value && !editor.innerText) {
                editor.value = text;
                editor.dispatchEvent(new Event('input', { bubbles: true }));
            }

            editor.dispatchEvent(new Event('change', { bubbles: true }));
            await new Promise(r => setTimeout(r, CONFIG.BEFORE_SAVE_DELAY));

            const saveBtn = document.querySelector('button.save.btn-primary');
            if (saveBtn) {
                saveBtn.click();
            } else {
                const modifier = isMac ? { metaKey: true } : { ctrlKey: true };
                editor.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', ...modifier, bubbles: true }));
            }

            for(let i=0; i<15; i++) {
                const stillOpen = document.querySelector('.ace_text-input, textarea:not([style*="display: none"])');
                if (!stillOpen) {
                    console.log(`‚úÖ ID ${id} –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω.`);
                    return;
                }
                await new Promise(r => setTimeout(r, CONFIG.SAVE_CHECK_DELAY));
            }
            row.querySelector('.non-editable-key-name')?.click();
        }
    }

    function fetchGemini(prompt) {
        const url = `https://generativelanguage.googleapis.com/v1/models/${CONFIG.MODEL}:generateContent?key=${CONFIG.GEMINI_API_KEY}`;
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: "POST",
                url: url,
                headers: { "Content-Type": "application/json" },
                data: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                onload: (res) => {
                    const r = JSON.parse(res.responseText);
                    if (res.status !== 200) reject(r.error?.message || "Error");
                    else resolve(r.candidates[0].content.parts[0].text);
                },
                onerror: () => reject("Network error")
            });
        });
    }
})();
